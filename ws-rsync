#!/usr/bin/env bash

ROOT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
CUR_WORK_DIR=$(pwd)
ProgName=$(basename $0)

DEFAULT_DIFF_TIME=3

mkdir -p $HOME/.ws-rsync/

function usage
{
    echo "basically, workspace-rsync will create .config_<name-of-workspace-dir> in your $HOME when you run the utility with out any confile
          then the tool will check whether or not the configure in $HOME then it will auto apply the configure"

    echo "usage: ws-rsync config --ssh keivn@my-sample-server --ssh-key $HOME/.ssh/sample_key --local $(pwd) --remote /mnt/my-project/"

    echo "   ";
    echo "  --ssh-acc               : Your ssh account kevin@kencancode ";
    echo "  --ssh-pass              : use ssh account password for authenticate; required sshpass";
    echo "  --ssh-key               : your ssh private key absolute path <~/home/kevin/.ssh/id_rsa>";
    echo "  --ssh-port              : custom ssh port";
    echo "  --remote                : remote work space dir /mnt/KEVIN/TestABC";
    echo "  --diff_time             : diff_time to check changed on local side";
    echo "  --sudo                  : sudo permission --sudo true/false";
    echo "  -h | --help             : Help";
}

function dump_config()
{
    ws_cfg_file=$(get_ws_config_file ${CUR_WORK_DIR})
    if [[ -f ${ws_cfg_file} ]];then
        cat ${ws_cfg_file}
    fi
}


function parse_conf_args
{
  # positional args
  args=()

  # named args
  while [[ "$1" != "" ]]; do
      case "$1" in
          --ssh-acc )                           ssh_acc="$2";   shift;;
          --ssh-port )                          ssh_port="$2"; shift;;
          --ssh-pass )                          ssh_pass="$2";   shift;;
          --ssh-key )                           ssh_key="$2";   shift;;
          --local )                             local_dir="$2";   shift;;
          --remote )                            remote_dir="$2";   shift;;
          --diff_time )                         diff_time="$2"; shift;;
          --sudo )                              sudo="$2"; shift;;
          -h | --help )                         usage;          exit;; # quit and show usage
          dump )                                dump_config; exit;;
          * )                           args+=("$1")             # if no match, add it to the positional args
      esac
      shift # move to next kv pair
  done
  set -- "${args[@]}"
}

function is_tracked_by_git(){
    dir=$1
    file=$2
    pushd ${dir} > /dev/null 2>&1
    inside_git_repo="$(git rev-parse --is-inside-work-tree ${dir} 2>/dev/null)"
    if [[ "$inside_git_repo" ]]; then
        git check-ignore "${dir}/${file}" >/dev/null 2>&1
        echo $?
    else
        echo 0
    fi
    popd > /dev/null 2>&1
}

function watch_dir_inotify(){
    watch_dir=$1
    inotifywait -mr --format '%e %w %f' -e close_write --exclude '/\.' --exclude '/\.git' ${watch_dir} | while read event dir file ; do
           ret=$(is_tracked_by_git ${dir} ${file})
           if [[ ${ret} ]]; then
               echo "update file $file by rsync"
               rsync_files_to_remote ${dir}${file}  >/dev/null 2>&1
           else
               echo "ignored update $file"
           fi
    done
}

function rsync_execute(){
    src=$1
    des=$2
    force_sync=$3

    SSH_OPTS="ssh -T -o Compression=no -x"
    RSYNC_CMD="rsync -aHAXxR --numeric-ids --progress --exclude=.git/ --exclude=*~"

    if [[ -f ${local_dir}/.gitignore ]]; then
        if [[ -z "$force_sync" || ${force_sync} == false ]]; then
            RSYNC_CMD="$RSYNC_CMD --exclude-from='${local_dir}/.gitignore'"
        fi
    fi
    if [[ ! -z ${sudo} ]];then
        RSYNC_CMD="$RSYNC_CMD --rsync-path=\"sudo rsync\""
    fi

    # SSH OPTIONS
    if [[ ! -z ${ssh_port} ]]; then
       SSH_OPTS="$SSH_OPTS -p ${ssh_port}"
    fi

    # if ssh_pass is used, then use ssh pass as authenticate method
    if [[ ! -z ${ssh_pass} ]];then
        SSHPASS_CMD="sshpass -p$ssh_pass"
        RSYNC_CMD="${SSHPASS_CMD} ${RSYNC_CMD} -e \"$SSH_OPTS\""
    else #otherwise, use ssh private key or non authenticate
        if [[ ! -z ${ssh_key} ]]; then
            SSH_OPTS="${SSH_OPTS} -i $ssh_key"
            RSYNC_CMD="${RSYNC_CMD} -e \"$SSH_OPTS\""
        else
            # Work arround for ":" if non ssh
            src=$(echo "$src" | tr ":" " ")
            des=$(echo "$des" | tr ":" " ")
        fi
    fi

    RSYNC_CMD="$RSYNC_CMD $src $des"
    rsync_execute_cmd=$(printf "%q " ${RSYNC_CMD};echo)
    printf "${rsync_execute_cmd}"
    printf "${rsync_execute_cmd}" | bash
}

function rsync_files_to_remote(){
    changed_file=$1

    local_realpath=$(realpath --relative-to=${local_dir} ${changed_file})
    local_file_dirpath=$(dirname "$local_realpath")

    src=${local_dir}/./${local_realpath}
    des=${ssh_acc}:"${remote_dir}"
    rsync_execute ${src} ${des} &
    return
}

function watch_dir() {
    ws_cfg_file=$(get_ws_config_file ${CUR_WORK_DIR})
    . ${ws_cfg_file}

    if [[ -z "${diff_time}" ]];then
        diff_time=3
    fi
    abs_local_dir=$(echo "$(cd "$(dirname "$1")" && pwd)/$(basename "$1")")
    echo watching folder ${abs_local_dir} every ${diff_time} secs.

    while [[ true ]]
    do
        files=`find ${abs_local_dir} -type f -newermt "$diff_time seconds ago"`
        if [[ ${files} != "" ]] ; then
            rsync_files_to_remote ${files} &
        fi
        sleep ${diff_time}
    done
}

get_ws_config_file() {
    echo "value of $1" >> /tmp/ws-rsync.log
    ABS_DIR_PATH=$1
    MD5_CUR_DIR=$(echo -n ${ABS_DIR_PATH} | md5sum | awk '{print $1}')
    config_file="$HOME/.ws-rsync/config_${MD5_CUR_DIR}"

    if [[ ${ABS_DIR_PATH} = "/" ]]; then
        echo "Not found configure file recursively, exit -1" >&2
        exit -1
    fi
    if [[ -f ${config_file} ]]; then
        echo ${config_file}
    else
        ret=$(get_ws_config_file $(dirname ${ABS_DIR_PATH}))
        echo ${ret}
    fi
    return
}

function get_ws_config(){
    ws_cfg_file=$(get_ws_config_file ${CUR_WORK_DIR})
    echo "Configure file is: $ws_cfg_file"
    if [[ ! -f "$ws_cfg_file" ]]; then
        echo 0
    fi
    . "${ws_cfg_file}"
    return 1
}

function write_ws_config(){
    ws_cfg_file=$1
    echo "ws configure file: $ws_cfg_file"
    echo "clean up the workspace configure file"
    echo  > ${ws_cfg_file}

    if [[ ! -z ${ssh_acc} ]]; then
        echo "${!ssh_acc@}=$ssh_acc" >> ${ws_cfg_file}
    fi

    if [[ ! -z ${ssh_key} ]]; then
        echo "${!ssh_key@}=$ssh_key" >> ${ws_cfg_file}
    fi

    if [[ ! -z ${ssh_port} ]]; then
        echo "${!ssh_port@}=$ssh_port" >> ${ws_cfg_file}
    fi

    if [[ ! -z ${ssh_pass} ]]; then
        echo "${!ssh_pass@}=$ssh_pass" >> ${ws_cfg_file}
    fi

    if [[ ! -z ${local_dir} ]]; then
        echo "${!local_dir@}=$local_dir" >> ${ws_cfg_file}
    fi

    if [[ ! -z ${remote_dir} ]]; then
        echo "${!remote_dir@}=$remote_dir" >> ${ws_cfg_file}
    fi

    if [[ -z ${diff_time} ]];then
        diff_time=${DEFAULT_DIFF_TIME}
    fi

    if [[ ! -z ${diff_time} ]]; then
        echo "${!diff_time@}=$diff_time" >> ${ws_cfg_file}
    fi

    if [[ ! -z ${sudo} ]]; then
        echo "${!sudo@}=$sudo" >> ${ws_cfg_file}
    fi

    # if diff_time is NULL then add default value is 3 secs

    return;
}

function validate_rsync_transportor() {
#    test_file="/tmp/rsync_test"
#    touch ${test_file}
#    rsync_files_to_remote $test_file
    return;
}


function validate_ssh_connection(){
    ws_cfg_file=$(get_ws_config_file ${CUR_WORK_DIR})
    if [[ -z "$ws_cfg_file" ]];then
        echo "error on get configure"
        run_init
    fi
    . ${ws_cfg_file}
    temp=""
    if [[ ! -z ${ssh_pass} ]];then
        retVal=$(sshpass -p${ssh_pass} ssh -p ${ssh_port} ${ssh_acc} exit);
        if [[ ${retVal} == 255 ]];then
            echo "ssh connection is not active"
            read -r "Press any key to continue or Ctrl-C to exit:" temp
        else
            echo "ssh connection is active"
            return
        fi
    fi

    if [[ ! -z ${ssh_key} ]];then
        retVal=$(ssh -q -i ${ssh_key} ${ssh_acc} exit);
        if [[ ${retVal} == 255 ]];then
            echo "ssh connection is not active"
            read -r "Press any key to continue or Ctrl-C to exit:" temp
        fi
    fi
}

function validate_ws_config(){
    ws_cfg_file=$(get_ws_config_file ${CUR_WORK_DIR})
    . ${ws_cfg_file}
    temp=""
    if [[ ! -d ${local_dir} ]]; then
        echo "Warmning look like $local_dir is not existed"
        read -r 'Press any key to continue or Ctrl-C to exit:' temp
        echo "create $local_dir"
        mkdir -p ${local_dir}
    fi
    validate_ssh_connection
    return
}

function validate_bool_input(){
    input="${1^^}" # capitalized input
    if [[ "${input}" == "NO" ]];then
        echo 0
    elif [[ "${input}" == "YES" ]];then
        echo 1
    else
        echo -1
    fi
}

function input_ssh_authenticate(){
    read -p 'Using private key to authenticate,default Yes (yes/no)': auth_private_key
    if [[ -z "${auth_private_key}" ]]; then
        auth_private_key="yes"
    fi
    auth_private_key=$(validate_bool_input ${auth_private_key})
    if [[ ${auth_private_key} == -1 ]]; then
        echo "Error on options using private key or not"
        auth_private_key=1
    fi
    if [[ ${auth_private_key} == 1 ]]; then
         read -p 'Enter your ssh private key:' ssh_key
    else
        read -sp 'Enter your ssh password: \n' ssh_pass
    fi
    read -p 'Enter your ssh port (Enter for default: 22) :' ssh_port
    if [[ -z ${ssh_port} || $((ssh_port)) != ${ssh_port} ]];then
        ssh_port=22
    fi
}
get_ws_config_file_path() {
    ABS_DIR_PATH=${CUR_WORK_DIR}
    MD5_CUR_DIR=$(echo -n ${ABS_DIR_PATH} | md5sum | awk '{print $1}')
    ws_cfg_file="$HOME/.ws-rsync/config_${MD5_CUR_DIR}"
    echo ${ws_cfg_file}
}

function run_init(){
    echo "run_init"
    ws_cfg_file=$(get_ws_config_file_path)
    local_dir=$(pwd)
    read -p "Enter your ssh account:" ssh_acc
    input_ssh_authenticate
    read -p "Enter your remote workspace:" remote_dir
    write_ws_config ${get_ws_config_file}
    return
}

function run_configue(){
    ws_cfg_file=$(get_ws_config_file ${CUR_WORK_DIR})
    if [[ ! -z "$ws_cfg_file" ]]; then
       . ${ws_cfg_file}
    else
        ABS_DIR_PATH=${CUR_WORK_DIR}
        MD5_CUR_DIR=$(echo -n ${ABS_DIR_PATH} | md5sum | awk '{print $1}')
        ws_cfg_file="$HOME/.ws-rsync/config_${MD5_CUR_DIR}"
    fi
    parse_conf_args "$@"
    write_ws_config ${ws_cfg_file}
    return;
}

function run_remote_local_sync(){
    ws_cfg_file=$(get_ws_config_file ${CUR_WORK_DIR})
    if [[ -z "$ws_cfg_file" ]];then
        echo "error on get configure"
        run_init
    fi
    . ${ws_cfg_file}

    echo "run_action_remote_local_sync"

    local_realpath=$(realpath --relative-to=${local_dir} ${CUR_WORK_DIR})

    remote_dirname=${remote_dir##*/}
    remote_parent_dir=$(dirname ${remote_dir})

    src=${ssh_acc}:"$remote_parent_dir/${remote_dirname}/./$local_realpath"
    des=${local_dir}
    echo "sync up all data in remote $src  to local $des"
    rsync_execute ${src} ${des}
    return
}

function run_local_remote_sync(){
    ws_cfg_file=$(get_ws_config_file ${CUR_WORK_DIR})
    if [[ -z "$ws_cfg_file" ]];then
        echo "error on get configure"
        run_init
    fi
    . ${ws_cfg_file}

    local_realpath=$(realpath --relative-to=${local_dir} ${CUR_WORK_DIR})

    echo "run_action_local_remote_sync"

    src=${local_dir}/./$local_realpath
    des=${ssh_acc}:"${remote_dir}/./"
    echo "sync up all data in local $src  to remote $des"
    rsync_execute ${src} ${des}
    return
}

function run_force_upload(){
    ws_cfg_file=$(get_ws_config_file ${CUR_WORK_DIR})
    if [[ -z "$ws_cfg_file" ]];then
        echo "error on get configure"
        run_init
    fi
    . ${ws_cfg_file}

    validate_ws_config
    download_entry=$1
    abs_download_entry=$(realpath -m ${download_entry})
    local_realpath=$(realpath --relative-to=${local_dir} -m ${abs_download_entry})

    src=${local_dir}/./${local_realpath}
    des=${ssh_acc}:"${remote_dir}/"

    rsync_execute ${src} ${des} true
}

function run_force_download(){
    ws_cfg_file=$(get_ws_config_file ${CUR_WORK_DIR})
    if [[ -z "$ws_cfg_file" ]];then
        echo "error on get configure"
        echo "please rerun ws-rsync init"
        exit -1
    fi
    . ${ws_cfg_file}
    validate_ws_config

    download_entry=$1
    local_realpath=$(realpath --relative-to=${local_dir} -m ${download_entry})
    src=${ssh_acc}:"${remote_dir}/./${local_realpath}"
    des="${local_dir}/./"

    rsync_execute ${src} ${des} true
}

function run_start(){
    echo "run_start"
    ws_cfg_file=$(get_ws_config_file ${CUR_WORK_DIR})
    if [[ ! -f "$ws_cfg_file" ]];then
        echo "error on get configure"
        run_init
    fi
    . ${ws_cfg_file}
    validate_ws_config
    # positional args
    args=()
    # named args
    while [[ "$1" != "" ]]; do
        case "$1" in
           -d | --daemon )                   daemon=true;  shift;;
           -h | --help )                     usage;          exit;; # quit and show usage
            * )                              args+=("$1")             # if no match, add it to the positional args
        esac
        shift # move to next kv pair
    done
    # restore positional args
    set -- "${args[@]}"

    if ! [[ -x "$(command -v inotifywait)" ]]; then
        echo 'Warmning: inotifytools is not installed' >&2
        echo "Warmning: wr-sync will use pooling check per $diff_time is not installed" >&2
        watch_dir
        exit 0
    fi
    relative_path=$(realpath --relative-to=${local_dir} ${CUR_WORK_DIR})
    echo "$relative_path" >> /tmp/ws-rsync.log
    watch_dir_inotify ${local_dir}/${relative_path}
    exit 0
}

function ssh_execute_cmd(){
    remote_dir=$1
    shift
    cmd=$@
    SSH_CMD=
    # if ssh_pass is used, then use ssh pass as authenticate method
    if [[ ! -z "${ssh_acc}" ]]; then
        SSH_CMD="ssh"
        if [[ ! -z ${ssh_pass} ]];then
            SSH_CMD="sshpass -p$ssh_pass $SSH_CMD"
        else #otherwise, use ssh private key or non authenticate
            if [[ ! -z ${ssh_key} ]]; then
                SSH_OPTS="-i $ssh_key"
                SSH_CMD="${SSH_CMD} ${SSH_OPTS}"
            fi
        fi

        if [[ ! -z ${ssh_port} ]];then
            SSH_CMD="$SSH_CMD -p $ssh_port"
        fi
        SSH_CMD="$SSH_CMD $ssh_acc"
    else
        echo "not existed ssh_acc, assume run in local"
    fi
    echo "${SSH_CMD} \"cd ${remote_dir} ; $cmd\"" |bash
}

function run_remote(){
    echo "run remote $@"
    cmd="$@"
    ws_cfg_file=$(get_ws_config_file ${CUR_WORK_DIR})
    if [[ -z "$ws_cfg_file" ]];then
        echo "error on get configure"
        echo "please rerun ws-rsync init"
        exit -1
    fi
    . ${ws_cfg_file}
    validate_ws_config
    local_realpath=$(realpath --relative-to=${local_dir} -m ${CUR_WORK_DIR})
    remote_dir=${remote_dir}/./${local_realpath}
    ssh_execute_cmd ${remote_dir} ${cmd}
}

# ws-rsync.sh init : you will run the initial steps for the current workspace dir"
# run the command bellow to update your configure which already done in initial step
# ws-rsync.sh config --ssh kevin@exampleserver --ssh-key $HOME/.ssh/examplekey ...
# After inital/configue then can use the script to run some action
# by default, the script will run the default action monitoring and sync the workspace
# with daemon options, then script will run in background for example
# ws-rsync.sh start --daemon  : workspace-rsync will monitor your configured workspace
# ws-rsync.sh stop : workspace-rsync will monitor your configured workspace
# when we think that remote side is latest version, then we need to sync up with remote site. In this case, that we will
# download the newer files from remote workspace
# ws-rsync.sh run remote-local-sync : run a sync up from local to remote: rsync download newer from remote to local/ scp download-replace everything from remote to local
# when we think that local side is latest version, then we need to update the newer files to remote workspace
# ws-rsync.sh run local-remote-sync : run a sync up from local to remote: rync  upload the newer from local to remote....
function run
{
    subcommand=$1
    action=$2
    case ${subcommand} in
    "" | "-h" | "--help")
        usage
        exit 0
        ;;
    "" | "init" )
        shift
        run_init
        exit 0
        ;;
    "" | "config" )
        shift
        run_configue $@
        exit 0
        ;;
    "" | "start" )
        shift
        run_start $@
        exit 0
        ;;
    "" | "run")
        shift
        action=$1
        shift
        echo "run action: ${subcommand}_${action} $@"
        ${subcommand}_${action} $@
        if [[ $? = 127 ]]; then
                echo "Error: '$subcommand' is not a known subcommand." >&2
                echo "     Run '$ProgName --help' for a list of known subcommands." >&2
                exit 1
            fi
        ;;
    "" | "call")
        shift
        echo "run command $@ remote"
        run_remote $@
    ;;
    *)
        echo "Error: '$subcommand' is not a known subcommand." >&2
        echo "       Run '$ProgName --help' for a list of known subcommands." >&2
        exit 1
        ;;
esac
}

run "$@";
#get_ws_config_fil
